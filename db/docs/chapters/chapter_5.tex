\chapter{Implementazione Triggers e Funzioni}

Sono riportati i trigger e le funzioni creati per la gestione dei vincoli individuati durante \intlink{ConstraintDictionary}{la ristrutturazione del database}.

Nonostante siano stati definiti trigger sia per \lstinline{INSERT} che per \lstinline{UPDATE}, quest'ultimi verrano spesso omessi nella documentazioni. Tali casi sono quelli in cui il trigger per \lstinline{UPDATE} esegue la stessa funzione di quello per \lstinline{INSERT}, rendendolo di fatto identico.

\section{Exception Handling}

Per una gestione più pulita degli errori si è deciso di creare una funzione che lanciasse tutte le eccezioni personalizzate, ricavandole da un'apposita tabella \textbf{custom\_error\_messages}.

Questa tabella si occupa di tener traccia dei codici di errore e dei messaggi di errore associati.

\begin{lstlisting}[caption={Creazione della tabella \textbf{custom\_error\_messages}}]
  CREATE TABLE custom_error_messages (
    error_code integer NOT NULL PRIMARY KEY,
    error_message text NOT NULL
  );
\end{lstlisting}

\begin{lstlisting}[caption={Creazione della funzione per gestire le eccezioni}]
  CREATE OR REPLACE FUNCTION raise_custom_error(p_error_code TEXT)
  RETURNS VOID AS $$
  DECLARE
    v_error_message TEXT;
  BEGIN
    -- Find error message in the custom_error_messages table 
    SELECT error_message INTO v_error_message
    FROM custom_error_messages
    WHERE error_code = p_error_code;
  
    -- Raise exception with the retrieved error message
    RAISE EXCEPTION USING 
              ERRCODE = p_error_code, 
              MESSAGE = v_error_message;
    
    -- If the error code given does not exist in the table, raise an exception to notify the user
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        RAISE EXCEPTION 'Error % not found', p_error_code;
  END;
  $$ LANGUAGE plpgsql;
\end{lstlisting}



\section{\textbf{isAddressForSomethingSpecific}}

Per gestire questo vincolo sono necessari due trigger, uno per la tabella \textbf{Account} e uno per la tabella \textbf{Deposit}.

Nonostante ciò, la funzione che dovranno eseguire è praticamente analoga, fatto salvo per dei dettagli inerenti alla tabella su cui si sta lavorando.

Si avrà infatti in entrambi i casi che la funzione dovrà controllare nella tabella tra le due in cui non è chiamato se esistono righe con lo stesso \textit{AddressNo}, \textit{Street}, \textit{ZipCode} e \textit{Country}.

Dovrà inoltre tenere di conto del tipo di deposito. Infatti se si sta lavorando su \textbf{Account} si dovranno escludere dalla ricerca i \textbf{Deposit} di tipo \textit{City}, mentre se si sta lavorando su \textbf{Deposit} si dovrà controllare che il tipo di deposito inserito non sia \textit{City}.

Si può dunque utilizzare \textbf{SQL Dinamico} per generalizzare la funzione e utilizzarla in entrambi i trigger.

Le \textit{trigger function} però non possono accettare argomenti in ingresso. Per ovviare a ciò si è utilizzata la variabile \lstinline{TG_ARGV}, un array speciale messo a disposizione da PostgreSQL che contiene gli argomenti passati alla funzione all'interno di un trigger.

Iterando tra gli elementi di questo array si può ottenere il tipo di tabella su cui si sta lavorando e passarlo alla funzione.

\begin{lstlisting}[caption={Creazione dei trigger per il vincolo \textbf{isAddressForSomethingSpecific}}]
  CREATE OR REPLACE TRIGGER isAddressForSomethingSpecificAccount_in
  BEFORE INSERT ON Account
  FOR EACH ROW
  EXECUTE PROCEDURE isAddressForSomethingSpecific_func('Deposit');

  CREATE OR REPLACE TRIGGER isAddressForSomethingSpecificDeposit_in
  BEFORE INSERT ON Deposit
  FOR EACH ROW
  EXECUTE PROCEDURE isAddressForSomethingSpecific_func('Account');
\end{lstlisting}

\newpage
\begin{lstlisting}[caption={Creazione della funzione \textbf{isAddressForSomethingSpecific\_func}}]
  CREATE OR REPLACE FUNCTION isAddressForSomethingSpecific_func()
  RETURNS TRIGGER
  AS 
  $$
    DECLARE 
      flag integer;
      queryp1 text = 'SELECT COUNT(*) 
                    FROM ';
      queryp2 text = ' 
                    WHERE (AddressNo = $1 AND 
                          Street = $2 AND 
                          ZipCode = $3 AND  
                          Country = $4';
      tableName text;
  BEGIN
      FOREACH tableName IN ARRAY TG_ARGV LOOP
  
        IF tableName = 'Deposit' THEN
          queryp2 = queryp2 || ' AND DepositType <> ''City'' ';
        ELSIF tableName = 'Account' THEN
          IF NEW.DepositType = 'City' THEN
            RETURN NEW;
          END IF;
        ELSE 
          perform raise_custom_error('E0003');
        END IF;
            
        queryp1 = queryp1 || tableName || queryp2 || ')';
        EXECUTE queryp1 into flag USING NEW.AddressNo, NEW.Street, NEW.ZipCode, NEW.Country;
        IF flag > 0 THEN
          perform raise_custom_error('E0002');
        END IF;
      END LOOP;
  
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;
\end{lstlisting}

\newpage

\section{\textbf{isShipmentDirectedInCorrectArea}}

Il vincolo è diviso in due casi, uno per le spedizioni dirette ai clienti e uno per le spedizioni dirette ai depositi.

In entrambi i casi però è necessario controllare che il trasporto associato alla spedizione abbia in programma per la data di spedizione la copertura della zona di destinazione.

In particolare il trasporto è adatto se non ha ancora zone programmate per quel giorno, oppure se ha come zona programmata proprio quella di destinazione.

In tal senso è possibile implementare questo vincolo utilizzando un corretto \textit{Exception Handling}.

Una volta recuperati i dati necessari a determinare la zona da coprire infatti possiamo dividere il problema in tre casi:

\begin{enumerate}
  \item Il trasporto non ha zone programmate per quel giorno: la spedizione è valida e va inserita la copertura per la zona della spedizione in \textbf{Covers}.
  \item Il trasporto ha come zona programmata proprio quella della spedizione: la spedizione è valida e non va inserita nessuna copertura.
  \item Il trasporto ha zone programmate per quel giorno ma non quella della spedizione: la spedizione non è valida e va lanciata un'eccezione.
\end{enumerate}

Possiamo notare ora che, fatta eccezione per il caso \(2\) risolvibile con un banale \lstinline{IF EXISTS}, gli altri due casi possono essere accorpati.

Infatti grazie al vincolo di unicità \textbf{onlyOneAreaPerDay} possiamo non preoccuparci di controllare se il trasporto è già impegnato in altra zona nella data di spedizione prima di inserire, poichè se ne occuperà \textbf{onlyOneAreaPerDay} lanciando un eccezione.

Trattando dunque separatamente il caso \(2\), che fortunamente è il più banale non dovendo fare nulla, possiamo accorpare i casi \(1\) e \(3\).

Per fare ciò andiamo a definire una funzione che si occupi di inserire la copertura per la zona di destinazione della spedizione, e che lanci un'eccezione se il trasporto è già impegnato in altra zona nella data di spedizione.

\newpage

\begin{lstlisting}[caption={funzione per inserimento in \textbf{Covers}}]
  CREATE OR REPLACE FUNCTION createCoversForShipment(Zc Covers.ZipCode%TYPE, Cy Covers.Country%TYPE, Tid Covers.transportId%TYPE, D Covers.Date%TYPE)
  RETURNS VOID AS $$
  BEGIN
    -- Excluding Case 2 where nothig has to be done
    IF NOT EXISTS (
        SELECT 1
        FROM Covers
        WHERE ZipCode = ZC
          AND Country = Cy
          AND transportid = Tid
          AND Date = D
      ) THEN
        -- Trying to insert the new cover
        INSERT INTO Covers
          VALUES (Tid, Zc, Cy, D);
    END IF;
    -- If It's Case 1 the function will end here
  EXCEPTION
    WHEN unique_violation THEN 
      -- Otherwise if it's Case 3 an exception will be raised
      perform raise_custom_error('E0006');
  END;
  $$ LANGUAGE plpgsql;
\end{lstlisting}

È necessario adesso individuare il modo di raccogliere i dati necessari alla funzione nei due casi descritti sopra.

Nel caso in cui la spedizione sia diretta verso un deposito, i dati relativi alla zona da coprire sono accessibili direttamente con l'utilizzo della chiave esterna, mentre i dati realtivi a data e trasporto sono presenti nella riga da inserire.

Per quanto riguarda spedizioni dirette ai clienti invece, i dati relativi alla zona da coprire vanno recuperati nella tabella \textbf{Account}, passando per la tabella \textbf{Order} tramite la tabella \textbf{Ships}.

Avendo però \textbf{Ships} delle chiavi esterne verso \textbf{Order} e \textbf{Shipment}, non è possibile far attivare il trigger con un inserimento su \textbf{Shipment}, poiché questo stesso trigger dovrebbe andare a cercare i dati in \textbf{Ships} che non è ancora stata popolata.

Di conseguenza è necessario che il trigger si attivi su \textbf{Ships}, recuperando eventualmente i dati da \textbf{Shipment}.

Contestualmente alla funzione che implementa il vincolo \textbf{isShipmentDirectedInCorrectArea} è possibile implementare anche il vincolo \textbf{isCityDepositShippingToClient}
poiché l'evento d'innesco è lo stesso, nonché i dati necessari alla sua implementazione.

Vediamo dunque innanzitutto la funzione che implementa il vincolo \textbf{isCityDepositShippingToClient}, per poi passare all'implementazione dei trigger e delle trigger function.

\newpage
\begin{lstlisting}[caption={Funzione per il vincolo \textbf{isCityDepositShippingToClient}}]
  CREATE OR REPLACE FUNCTION isCityDepositShippingToClient(Zc Covers.ZipCode%TYPE, Cy Covers.Country%TYPE, Did Covers.transportId%TYPE)
  RETURNS VOID AS $$
    DECLARE 
      a_city Area.City%TYPE;
      a_state Area.State%TYPE;
      a_worldzone Area.WorldZone%TYPE;
      d_city Area.City%TYPE;
      d_state Area.State%TYPE;
      d_country Area.Country%TYPE;
      d_worldzone Area.WorldZone%TYPE;
    BEGIN

      -- retriving account location data
      SELECT City, State, WorldZone
      INTO a_city, a_state, a_worldzone
      FROM Area
      WHERE ZipCode=Zc AND Country=Cy;

      -- retriving deposit location data
      SELECT City, State, Country, WorldZone
      INTO d_city, d_state, d_country, d_worldzone
      FROM deposit NATURAL JOIN area
      WHERE depositid=Did;

      -- checking if cities matches
      IF d_city <> a_city OR d_state <> a_state OR d_country <> Cy OR d_worldzone <> a_worldd_worldzone THEN
        perform raise_custom_error('E0008');
      END IF; 
    END;
  $$ LANGUAGE plpgsql;
\end{lstlisting}

Come detto in precedenza i trigger per questo vincolo si attiveranno uno su \textbf{Ships} e un altro su \textbf{Shipment}.

\begin{lstlisting}[caption={Trigger per il vincolo \textbf{isShipmentDirectedInCorrectArea}}]
  CREATE OR REPLACE TRIGGER isShipmentDirectedInCorrectAreaAccount_in
  BEFORE INSERT ON Ships
  FOR EACH ROW 
  EXECUTE PROCEDURE isShipmentDirectedInCorrectAreaAccount_func();
  
  CREATE OR REPLACE TRIGGER isShipmentDirectedInCorrectAreaDeposit_in
  BEFORE INSERT ON Shipment 
  FOR EACH ROW 
  EXECUTE PROCEDURE isShipmentDirectedInCorrectAreaDeposit_func();
\end{lstlisting}

\newpage
Vediamo in ultimo le \textit{trigger function} che implementano il vincolo.

\begin{lstlisting}[caption={Funzione per le spedizioni verso clienti}]
  CREATE OR REPLACE FUNCTION isShipmentDirectedInCorrectAreaAccount_func() 
  RETURNS TRIGGER AS $$
  DECLARE 
    ZCode Account.ZipCode%TYPE;
    Cy Account.Country%TYPE;
    Tid Shipment.transportId%TYPE;
    SDate Shipment.ShippingDate%TYPE;
    Sdeposit Shipment.ShippedFrom%TYPE;
  BEGIN 
    -- Assuring it's the correct case
    IF EXISTS (
      SELECT 1
      FROM Shipment
      WHERE ShipmentID=NEW.ShipmentID AND DirectedTo IS NOT NULL
    ) THEN
      RETURN NEW;
    END IF;
  
    -- Retrieving the data needed
    SELECT ZipCode, Country 
      INTO ZCode, Cy
      FROM "Order" NATURAL JOIN Account
      WHERE OrderId = NEW.OrderID;

      
    SELECT transportId, ShippingDate, ShippedFrom
      INTO Tid, Sdate, Sdeposit
      FROM shipment
      WHERE shipmentid = NEW.shipmentid;
        
    -- calling the function to check isCityDepositShippingToClient constraint
    perform isCityDepositShippingToClient(ZCode, Cy, Sdeposit);

    -- Calling the function to insert the cover
    perform createCoversForShipment(ZCode, Cy, Tid, D);

    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
\end{lstlisting}

\newpage
\begin{lstlisting}[caption={Funzione per le spedizioni verso depositi}]
  CREATE OR REPLACE FUNCTION isShipmentDirectedInCorrectAreaDeposit_func() 
  RETURNS TRIGGER AS $$
  DECLARE 
    ZCode Deposit.ZipCode%TYPE;
    Cy Deposit.Country%TYPE;
  BEGIN 
    -- Assuring it's the correct case
    IF NEW.DirectedTo IS NULL THEN 
      RETURN NEW;
    END IF;

    -- Retrieving the data needed
    SELECT ZipCode, Country 
    INTO ZCode, Cy
    FROM deposit
    WHERE depositid = NEW.DirectedTo;

    -- Calling the function to insert the cover
    perform createCoversForShipment(ZCode, Cy, NEW.transportId, NEW.ShippingDate);
    RETURN NEW;

  END;
  $$ LANGUAGE plpgsql;
\end{lstlisting}


\section{\textbf{isShipmentContainingValidOrders}}

Il vincolo si assicura che non venga spedito un prodotto da un deposito nel quale quest ultimo non sia presente.

In particolare dunque, il trigger controlla se, all'inserimento di una riga in \textbf{Ships} esista una riga in \textbf{Stores} con lo stesso \textit{Name} e \textit{Supplier} del prodotto nell'\textbf{Order} e \textit{DepositID} della spedizione con un campo \textbf{Quantity} sufficiente a soddisfare quella richiesta nell'\textbf{Order}.

Successivamente se tutto è andato bene, decrementa la quantità del prodotto nel deposito.

\begin{lstlisting}[caption={Creazione trigger \textbf{isShipmentContainingValidOrders}}]
  CREATE OR REPLACE TRIGGER isShipmentContainingValidOrders_in
  BEFORE INSERT ON ships
  FOR EACH ROW
  EXECUTE PROCEDURE isShipmentContainingValidOrders_func();
\end{lstlisting}

\newpage

\begin{lstlisting}[caption={Creazione funzione \textbf{isShipmentContainingValidOrders\_func}}]
  CREATE OR REPLACE FUNCTION isShipmentContainingValidOrders_func()
  RETURNS TRIGGER AS $$
  DECLARE
    QTY stores.quantity%TYPE;
    PName product.name%TYPE;
    PSupply product.supplier%TYPE;
    DID deposit.depositid%TYPE;
  BEGIN 
    -- retrieving order data
    SELECT quantity , name , supplier 
      INTO QTY , PName , PSupply
      FROM "Order" NATURAL JOIN PRODUCT
      WHERE OrderID = NEW.OrderID;
    
    -- retrieving deposit data
    SELECT shippedfrom
      INTO DID
      FROM shipment
      WHERE shipmentID = NEW.shipmentID;
  
    -- checking if the deposit has enough quantity of the product
    IF NOT EXISTS (
        SELECT 1
          FROM stores
          WHERE depositid = DID AND 
                name = PName AND 
                supplier = PSupply 
                AND quantity >= QTY
      ) THEN
      -- if not, raise an exception
      perform raise_custom_error('E0013');
    END IF;
    
    -- Otherwise decrement the quantity of the product in the deposit
    UPDATE stores
      SET quantity = quantity - QTY
      WHERE depositid = DID AND 
            name = PName AND 
            supplier = PSupply;
    
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
\end{lstlisting}

\newpage
\section{Triggers per \textit{UPDATE ON Shipment}}

Gli ultimi due trigger visti sono entrambi vincoli che, completamente o in parte, sono relativi alla tabella \textbf{Shipment} ma che si attivano sulla tabella \textbf{Ships}.

In questi due casi specifici inoltre, la specifica \lstinline{ON UPDATE CASCADE} della \lstinline{FOREIGN KEY} non è sufficiente a garantire la consistenza dei dati in caso di aggiornamento della tabella \textbf{Shipment}, facendo i trigger affidamento a campi diversi da \textbf{ShipmentID}.

Infatti nel caso si andasse a modificare una \textbf{Shipment} si potrebbero alterare dati utili alla funzione \textbf{isShipmentDirectedInCorrectAreaAccount\_func}, che non verrebbe richiamata, o ancora peggio si potrebbe passare da un caso all'altro. 

Di conseguenza, per l'\lstinline{UPDATE ON} \textbf{Shipment} è necessario definire una funzione ad hoc che si occupi di controllare i vincoli precedenti sia per quanto riguarda \textbf{Shipment} che per quanto riguarda \textbf{Ships}.

In particolare questa funzione, dopo aver controllata che la spedizione non sia ancora arrivata, andrà a chiamare due \textbf{procedure} che si occuperanno di verificare i vincoli visti in precedenza, fornendo alla funzione i dati necessari alla modifica di altre tabelle se non ci sono stati errori.
\subsection{Procedura \textbf{checkCorrectArea}}

Questa procedura si occupa di verificare che l'\textbf{Area} in cui la \textbf{Shipment} è diretta sia ancora coerente coi dati inseriti.

Per fare ciò la funzione si avvale di un altra funzione analoga a \textbf{createCoversForShipment} ma che si occupa dell'update, ovvero \textbf{updateCoversForShipment}.

I parametri necessari a questa procedura sono tutti recuperabili grazie all'utilizzo del record \textbf{NEW}, tranne che per quelli relativi ad \textbf{Area}, che dipendono dal caso in cui ci troviamo.

Nel caso la spedizione sia diretta verso un \textbf{Deposit}, sarà sufficiente recuperare i dati relativi all'\textbf{Area} del deposito \textbf{DirectedTo}.

Altrimenti, sarà necessario innanzitutto controllare se sono stati già inseriti ordini per quella spedizione. In caso negativo l'unica cosa da fare sarà eliminare eventuali coperture precedenti non più valide.
Se invece esistono già degli ordini relativi a quella spedizione, bisognerà innanzitutto controllare che tutti gli ordini siano diretti verso clienti nella stessa area, potendo i mezzi di trasporto coprirne una sola per spedizione.

A quel punto sarà necessario controllare che il deposito di partenza si trovi nella stessa città di destinazione della spedizione, e in caso negativo lanciare l'eccezione utilizzata in \textbf{isCityDepositShippingToClient}.
Ciò è fatto tramite l'utilizzo della funzione \textbf{isSameCity} che, dati in input le \lstinline{PRIMARY KEY} di due \textbf{Area} verifica che appartengano alla stessa città.

I dati relativi all'\textbf{Area} di destinazione verranno infine restituiti dalla procedura tramite \lstinline{OUT} per permettere alla funzione di aggiornare i dati di \textbf{Covers}.
\newpage
\begin{lstlisting}[caption={Procedure \textbf{checkCorrectArea}}]
  CREATE OR REPLACE PROCEDURE checkCorrectArea( New IN Shipment, Zcode OUT area.zipcode%TYPE, Cy OUT area.country%TYPE, coverNeedsUpdate OUT BOOLEAN)
  AS $$
  DECLARE
    Zcode2 area.zipcode%TYPE;
    Cy2 area.country%TYPE;
  BEGIN 
    IF NEW.DirectedTo IS NOT NULL THEN
      SELECT ZipCode, Country 
        INTO ZCode, Cy
        FROM Deposit
        WHERE DepositID = NEW.DirectedTo;
    ELSE
    -- for shipments to clients, all orders must be directed to the same area
    -- at first I check if there are at least one order for that shipment
      IF NOT EXISTS (
        SELECT 1
          FROM Ships 
          WHERE ShipmentID = NEW.ShipmentID
      ) THEN
        -- if not, I don't have to update the covers table
        coverNeedsUpdate = FALSE;
      ELSE
        -- When it's assured that at least one order exists I can pick one random order and check if all the others are directed to the same area
        SELECT ZipCode, Country 
          INTO ZCode, Cy
          FROM Ships NATURAL JOIN "Order" NATURAL JOIN Account
          WHERE ShipmentID = NEW.ShipmentID
          LIMIT 1;
        IF EXISTS (
          SELECT 1
            FROM Ships NATURAL JOIN "Order" NATURAL JOIN Account
            WHERE ShipmentID = NEW.ShipmentID AND
                  (ZipCode <> ZCode OR Country <> Cy)
        ) THEN
          perform raise_custom_error('E0016');
        END IF;
        -- now, I have to check if the new deposit is in the same city
        SELECT ZipCode, Country 
          INTO ZCode2, Cy2
          FROM deposit
          WHERE DepositID = NEW.ShippedFrom;
        IF NOT isSameCity(ZCode, Cy, ZCode2, Cy2) THEN
          perform raise_custom_error('E0008');
        END IF;
      END IF;
    END IF;
  END;
  $$ LANGUAGE plpgsql;
\end{lstlisting}

\subsection{Verifica Valid Orders}

La seconda procedura si occupa di controllare che la spedizione contenga ancora ordini validi, ovvero che il \textit{nuovo \textbf{ShippedFrom}} contenga tutti i prodotti in quantità sufficiente per essere spediti.

Per fare ciò è sufficiente controllare che per ogni prodotto presente nella spedizione, il deposito di partenza abbia una quantità sufficiente a soddisfare quella richiesta, in caso contrario si dovrà sollevare un eccezione.

Anche in questo caso tutti i dati necessari alla procedura sono recuperabili dal record \textbf{NEW}, non dovendo restituire nulla in questo caso alla funzione, dovendo in ogni caso reiterare tra i prodotti per aggioranre \textbf{Stores}.

\begin{lstlisting}[caption={Procedure \textbf{checkValidOrder}}]
  CREATE OR REPLACE PROCEDURE checkValidOrder( New IN Shipment)
  LANGUAGE plpgsql
  AS $$
    DECLARE
      QTY stores.quantity%TYPE;
      PName product.name%TYPE;
      PSupply product.supplier%TYPE;
      shipped_order Ships%ROWTYPE;
    BEGIN
      FOR shipped_order IN (SELECT * FROM Ships WHERE ShipmentID=NEW.ShipmentID) LOOP
  
          -- for each order ...
          SELECT quantity , name , supplier 
            INTO QTY , PName , PSupply
            FROM "Order" NATURAL JOIN PRODUCT
            WHERE OrderID = shipped_order.OrderID;
  
          -- the new deposit has to have enough products to satisfy the order?
          IF NOT EXISTS (
            SELECT 1
              FROM stores
              WHERE depositid = NEW.ShippedFrom AND name = PName AND supplier = PSupply AND quantity >= QTY
          ) THEN
            -- if not, raise error
            perform raise_custom_error('E0015');
          END IF;
        END LOOP;
    END;
  $$;
\end{lstlisting}

\newpage
\subsection{Aggiornamenti conclusivi}

Conclusi tutti controlli, se nessuna eccezione è stata sollevata, è necessario aggiornare le tabelle \textbf{Covers} e \textbf{Stores}.

\begin{lstlisting}[caption={Sezione di aggiornamento finale}]
  -- if everything is ok, function can procede to the updates
  IF coverNeedsUpdate THEN
    -- try to update the covers table, if fails, raise error
    -- In case shipment is directed to clients ZCode and Cy are the one from clients, otherwise they are the one from directedTo deposit
    perform updateCoversForShipment( OLD.ShippingDate, OLD.TransportID, ZCode, Cy, NEW.ShippingDate, NEW.TransportID);
  ELSE 
    DELETE FROM covers 
            WHERE shippingdate = OLD.ShippingDate AND 
                  transportid = OLD.TransportID;
  END IF;

  FOR shipped_order IN (SELECT * FROM Ships WHERE ShipmentID=NEW.ShipmentID) LOOP
      -- for each order ...
      SELECT quantity , name , supplier 
        INTO QTY , PName , PSupply
        FROM "Order" NATURAL JOIN PRODUCT
        WHERE OrderID = shipped_order.OrderID;

      -- restore the products in the old deposit
      UPDATE stores
        SET quantity = quantity + QTY
        WHERE depositid = OLD.ShippedFrom AND name = PName AND supplier = PSupply;
      -- remove the products from the new deposit
      UPDATE stores
        SET quantity = quantity - QTY
        WHERE depositid = NEW.ShippedFrom AND name = PName AND supplier = PSupply;
  END LOOP;
\end{lstlisting}
\newpage
\begin{lstlisting}[caption={Funzione completa}]
  CREATE OR REPLACE FUNCTION uninadelivery.shipmentdataconsistency_func() RETURNS trigger
  AS $$
  DECLARE
    QTY stores.quantity%TYPE;
    PName product.name%TYPE;
    PSupply product.supplier%TYPE;
    ZCode area.zipcode%TYPE;
    Cy area.country%TYPE;
    coverNeedsUpdate BOOLEAN = TRUE;
    shipped_order Ships%ROWTYPE;
  BEGIN
    -- if the shipment has already arrived, cannot be modified
    IF OLD.HasArrived = TRUE THEN
      perform raise_custom_error('E0017');
    END IF;
    -- check for correct area
    call checkCorrectArea(NEW, OLD, ZCode, Cy, coverNeedsUpdate);
    -- if the starting deposit has changed, check for order validity
    IF NEW.ShippedFrom <> OLD.ShippedFrom THEN
      call checkValidOrder(NEW);
    END IF;
    -- if everything is ok, function can procede to the updates
    IF coverNeedsUpdate THEN
      -- try to update the covers table, if fails, raise error
      perform updateCoversForShipment( OLD.ShippingDate, OLD.TransportID, ZCode, Cy, NEW.ShippingDate, NEW.TransportID);
    ELSE 
      DELETE FROM covers 
              WHERE shippingdate = OLD.ShippingDate AND 
                    transportid = OLD.TransportID;
    END IF;
    FOR shipped_order IN (SELECT * FROM Ships WHERE ShipmentID=NEW.ShipmentID) LOOP
        SELECT quantity , name , supplier 
          INTO QTY , PName , PSupply
          FROM "Order" NATURAL JOIN PRODUCT
          WHERE OrderID = shipped_order.OrderID;
        -- restore the products in the old deposit
        UPDATE stores
          SET quantity = quantity + QTY
          WHERE depositid = OLD.ShippedFrom AND name = PName AND supplier = PSupply;
        -- remove the products from the new deposit
        UPDATE stores
          SET quantity = quantity - QTY
          WHERE depositid = NEW.ShippedFrom AND name = PName AND supplier = PSupply;
    END LOOP;
    RETURN NEW;
  END;
  $$ LANGUAGE plpgsql;
\end{lstlisting}
% TODO @zGenny @RiccardoElena basic structure of db should work just fine. we need to refine update and delete behaviour to maintain consistency
% [ ] in particular the triggger to autmatically update occupiedspace in deposit or transport